diff -ru SDL.orig/include/SDL_blendmode.h SDL/include/SDL_blendmode.h
--- SDL.orig/include/SDL_blendmode.h	2017-09-10 20:09:20.000000000 +0200
+++ SDL/include/SDL_blendmode.h	2017-09-16 15:26:40.000000000 +0200
@@ -39,17 +39,10 @@
  */
 typedef enum
 {
-    SDL_BLENDMODE_NONE = 0x00000000,     /**< no blending
-                                              dstRGBA = srcRGBA */
-    SDL_BLENDMODE_BLEND = 0x00000001,    /**< alpha blending
-                                              dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
-                                              dstA = srcA + (dstA * (1-srcA)) */
-    SDL_BLENDMODE_ADD = 0x00000002,      /**< additive blending
-                                              dstRGB = (srcRGB * srcA) + dstRGB
-                                              dstA = dstA */
-    SDL_BLENDMODE_MOD = 0x00000004       /**< color modulate
-                                              dstRGB = srcRGB * dstRGB
-                                              dstA = dstA */
+    SDL_BLENDMODE_NONE = 0x00000000,     /**< No blending */
+    SDL_BLENDMODE_BLEND = 0x00000001,    /**< dst = (src * A) + (dst * (1-A)) */
+    SDL_BLENDMODE_ADD = 0x00000002,      /**< dst = (src * A) + dst */
+    SDL_BLENDMODE_MOD = 0x00000004       /**< dst = src * dst */
 } SDL_BlendMode;
 
 /* Ends C function definitions when using C++ */
diff -ru SDL.orig/include/SDL_surface.h SDL/include/SDL_surface.h
--- SDL.orig/include/SDL_surface.h	2017-09-10 20:09:20.000000000 +0200
+++ SDL/include/SDL_surface.h	2017-09-16 15:26:40.000000000 +0200
@@ -399,42 +399,44 @@
  *
  *  The blit function should not be called on a locked surface.
  *
- *  The blit semantics for surfaces with and without blending and colorkey
+ *  The blit semantics for surfaces with and without alpha and colorkey
  *  are defined as follows:
  *  \verbatim
     RGBA->RGB:
-      Source surface blend mode set to SDL_BLENDMODE_BLEND:
-        alpha-blend (using the source alpha-channel and per-surface alpha)
+      SDL_SRCALPHA set:
+        alpha-blend (using alpha-channel).
         SDL_SRCCOLORKEY ignored.
-      Source surface blend mode set to SDL_BLENDMODE_NONE:
+      SDL_SRCALPHA not set:
         copy RGB.
         if SDL_SRCCOLORKEY set, only copy the pixels matching the
         RGB values of the source color key, ignoring alpha in the
         comparison.
 
     RGB->RGBA:
-      Source surface blend mode set to SDL_BLENDMODE_BLEND:
-        alpha-blend (using the source per-surface alpha)
-      Source surface blend mode set to SDL_BLENDMODE_NONE:
+      SDL_SRCALPHA set:
+        alpha-blend (using the source per-surface alpha value);
+        set destination alpha to opaque.
+      SDL_SRCALPHA not set:
         copy RGB, set destination alpha to source per-surface alpha value.
       both:
         if SDL_SRCCOLORKEY set, only copy the pixels matching the
         source color key.
 
     RGBA->RGBA:
-      Source surface blend mode set to SDL_BLENDMODE_BLEND:
-        alpha-blend (using the source alpha-channel and per-surface alpha)
+      SDL_SRCALPHA set:
+        alpha-blend (using the source alpha channel) the RGB values;
+        leave destination alpha untouched. [Note: is this correct?]
         SDL_SRCCOLORKEY ignored.
-      Source surface blend mode set to SDL_BLENDMODE_NONE:
+      SDL_SRCALPHA not set:
         copy all of RGBA to the destination.
         if SDL_SRCCOLORKEY set, only copy the pixels matching the
         RGB values of the source color key, ignoring alpha in the
-        comparison.
+       comparison.
 
     RGB->RGB:
-      Source surface blend mode set to SDL_BLENDMODE_BLEND:
-        alpha-blend (using the source per-surface alpha)
-      Source surface blend mode set to SDL_BLENDMODE_NONE:
+      SDL_SRCALPHA set:
+        alpha-blend (using the source per-surface alpha value).
+      SDL_SRCALPHA not set:
         copy RGB.
       both:
         if SDL_SRCCOLORKEY set, only copy the pixels matching the
diff -ru SDL.orig/src/render/direct3d/SDL_render_d3d.c SDL/src/render/direct3d/SDL_render_d3d.c
--- SDL.orig/src/render/direct3d/SDL_render_d3d.c	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/direct3d/SDL_render_d3d.c	2017-09-16 15:26:40.000000000 +0200
@@ -182,7 +182,6 @@
     D3DPRESENT_PARAMETERS pparams;
     SDL_bool updateSize;
     SDL_bool beginScene;
-    SDL_bool enableSeparateAlphaBlend;
     D3DTEXTUREFILTERTYPE scaleMode[8];
     IDirect3DSurface9 *defaultRenderTarget;
     IDirect3DSurface9 *currentRenderTarget;
@@ -1357,12 +1356,6 @@
                                         D3DBLEND_SRCALPHA);
         IDirect3DDevice9_SetRenderState(data->device, D3DRS_DESTBLEND,
                                         D3DBLEND_INVSRCALPHA);
-        if (data->enableSeparateAlphaBlend) {
-            IDirect3DDevice9_SetRenderState(data->device, D3DRS_SRCBLENDALPHA,
-                                            D3DBLEND_ONE);
-            IDirect3DDevice9_SetRenderState(data->device, D3DRS_DESTBLENDALPHA,
-                                            D3DBLEND_INVSRCALPHA);
-        }
         break;
     case SDL_BLENDMODE_ADD:
         IDirect3DDevice9_SetRenderState(data->device, D3DRS_ALPHABLENDENABLE,
@@ -1371,12 +1364,6 @@
                                         D3DBLEND_SRCALPHA);
         IDirect3DDevice9_SetRenderState(data->device, D3DRS_DESTBLEND,
                                         D3DBLEND_ONE);
-        if (data->enableSeparateAlphaBlend) {
-            IDirect3DDevice9_SetRenderState(data->device, D3DRS_SRCBLENDALPHA,
-                                            D3DBLEND_ZERO);
-            IDirect3DDevice9_SetRenderState(data->device, D3DRS_DESTBLENDALPHA,
-                                            D3DBLEND_ONE);
-        }
         break;
     case SDL_BLENDMODE_MOD:
         IDirect3DDevice9_SetRenderState(data->device, D3DRS_ALPHABLENDENABLE,
@@ -1385,12 +1372,6 @@
                                         D3DBLEND_ZERO);
         IDirect3DDevice9_SetRenderState(data->device, D3DRS_DESTBLEND,
                                         D3DBLEND_SRCCOLOR);
-        if (data->enableSeparateAlphaBlend) {
-            IDirect3DDevice9_SetRenderState(data->device, D3DRS_SRCBLENDALPHA,
-                                            D3DBLEND_ZERO);
-            IDirect3DDevice9_SetRenderState(data->device, D3DRS_DESTBLENDALPHA,
-                                            D3DBLEND_ONE);
-        }
         break;
     }
 }
diff -ru SDL.orig/src/render/opengl/SDL_glfuncs.h SDL/src/render/opengl/SDL_glfuncs.h
--- SDL.orig/src/render/opengl/SDL_glfuncs.h	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/opengl/SDL_glfuncs.h	2017-09-16 15:26:40.000000000 +0200
@@ -36,7 +36,6 @@
                 (GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat,
                  const GLubyte *))
 SDL_PROC(void, glBlendFunc, (GLenum, GLenum))
-SDL_PROC(void, glBlendFuncSeparate, (GLenum, GLenum, GLenum, GLenum))
 SDL_PROC_UNUSED(void, glCallList, (GLuint))
 SDL_PROC_UNUSED(void, glCallLists, (GLsizei, GLenum, const GLvoid *))
 SDL_PROC(void, glClear, (GLbitfield))
diff -ru SDL.orig/src/render/opengl/SDL_render_gl.c SDL/src/render/opengl/SDL_render_gl.c
--- SDL.orig/src/render/opengl/SDL_render_gl.c	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/opengl/SDL_render_gl.c	2017-09-16 15:26:40.000000000 +0200
@@ -1095,17 +1095,17 @@
         case SDL_BLENDMODE_BLEND:
             data->glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
             data->glEnable(GL_BLEND);
-            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            data->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
             break;
         case SDL_BLENDMODE_ADD:
             data->glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
             data->glEnable(GL_BLEND);
-            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
+            data->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
             break;
         case SDL_BLENDMODE_MOD:
             data->glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
             data->glEnable(GL_BLEND);
-            data->glBlendFuncSeparate(GL_ZERO, GL_SRC_COLOR, GL_ZERO, GL_ONE);
+            data->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
             break;
         }
         data->current.blendMode = blendMode;
diff -ru SDL.orig/src/render/opengles/SDL_glesfuncs.h SDL/src/render/opengles/SDL_glesfuncs.h
--- SDL.orig/src/render/opengles/SDL_glesfuncs.h	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/opengles/SDL_glesfuncs.h	2017-09-16 15:26:40.000000000 +0200
@@ -21,7 +21,6 @@
 
 SDL_PROC(void, glBindTexture, (GLenum, GLuint))
 SDL_PROC(void, glBlendFunc, (GLenum, GLenum))
-SDL_PROC_OES(void, glBlendFuncSeparateOES, (GLenum, GLenum, GLenum, GLenum))
 SDL_PROC(void, glClear, (GLbitfield))
 SDL_PROC(void, glClearColor, (GLclampf, GLclampf, GLclampf, GLclampf))
 SDL_PROC(void, glColor4f, (GLfloat, GLfloat, GLfloat, GLfloat))
diff -ru SDL.orig/src/render/opengles/SDL_render_gles.c SDL/src/render/opengles/SDL_render_gles.c
--- SDL.orig/src/render/opengles/SDL_render_gles.c	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/opengles/SDL_render_gles.c	2017-09-16 15:26:40.000000000 +0200
@@ -131,7 +131,6 @@
 
     SDL_bool useDrawTexture;
     SDL_bool GL_OES_draw_texture_supported;
-    SDL_bool GL_OES_blend_func_separate_supported;
 } GLES_RenderData;
 
 typedef struct
@@ -400,10 +399,6 @@
     }
     data->framebuffers = NULL;
 
-    if (SDL_GL_ExtensionSupported("GL_OES_blend_func_separate")) {
-        data->GL_OES_blend_func_separate_supported = SDL_TRUE;
-    }
-
     /* Set up parameters for rendering */
     GLES_ResetState(renderer);
 
@@ -755,29 +750,17 @@
         case SDL_BLENDMODE_BLEND:
             data->glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
             data->glEnable(GL_BLEND);
-            if (data->GL_OES_blend_func_separate_supported) {
-                data->glBlendFuncSeparateOES(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
-            } else {
-                data->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-            }
+            data->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
             break;
         case SDL_BLENDMODE_ADD:
             data->glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
             data->glEnable(GL_BLEND);
-            if (data->GL_OES_blend_func_separate_supported) {
-                data->glBlendFuncSeparateOES(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
-            } else {
-                data->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
-            }
+            data->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
             break;
         case SDL_BLENDMODE_MOD:
             data->glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
             data->glEnable(GL_BLEND);
-            if (data->GL_OES_blend_func_separate_supported) {
-                data->glBlendFuncSeparateOES(GL_ZERO, GL_SRC_COLOR, GL_ZERO, GL_ONE);
-            } else {
-                data->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
-            }
+            data->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
             break;
         }
         data->current.blendMode = blendMode;
diff -ru SDL.orig/src/render/opengles2/SDL_gles2funcs.h SDL/src/render/opengles2/SDL_gles2funcs.h
--- SDL.orig/src/render/opengles2/SDL_gles2funcs.h	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/opengles2/SDL_gles2funcs.h	2017-09-16 15:26:40.000000000 +0200
@@ -23,6 +23,7 @@
 SDL_PROC(void, glAttachShader, (GLuint, GLuint))
 SDL_PROC(void, glBindAttribLocation, (GLuint, GLuint, const char *))
 SDL_PROC(void, glBindTexture, (GLenum, GLuint))
+SDL_PROC(void, glBlendFunc, (GLenum, GLenum))
 SDL_PROC(void, glBlendFuncSeparate, (GLenum, GLenum, GLenum, GLenum))
 SDL_PROC(void, glClear, (GLbitfield))
 SDL_PROC(void, glClearColor, (GLclampf, GLclampf, GLclampf, GLclampf))
diff -ru SDL.orig/src/render/opengles2/SDL_render_gles2.c SDL/src/render/opengles2/SDL_render_gles2.c
--- SDL.orig/src/render/opengles2/SDL_render_gles2.c	2017-09-10 20:09:20.000000000 +0200
+++ SDL/src/render/opengles2/SDL_render_gles2.c	2017-09-16 15:26:40.000000000 +0200
@@ -1343,15 +1343,15 @@
             break;
         case SDL_BLENDMODE_BLEND:
             data->glEnable(GL_BLEND);
-            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE);
             break;
         case SDL_BLENDMODE_ADD:
             data->glEnable(GL_BLEND);
-            data->glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE, GL_ZERO, GL_ONE);
+            data->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
             break;
         case SDL_BLENDMODE_MOD:
             data->glEnable(GL_BLEND);
-            data->glBlendFuncSeparate(GL_ZERO, GL_SRC_COLOR, GL_ZERO, GL_ONE);
+            data->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
             break;
         }
         data->current.blendMode = blendMode;
diff -ru SDL.orig/src/video/SDL_blit_0.c SDL/src/video/SDL_blit_0.c
--- SDL.orig/src/video/SDL_blit_0.c	2017-09-10 20:09:21.000000000 +0200
+++ SDL/src/video/SDL_blit_0.c	2017-09-16 15:26:40.000000000 +0200
@@ -363,10 +363,7 @@
     SDL_PixelFormat *dstfmt = info->dst_fmt;
     int dstbpp;
     int c;
-    Uint32 pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB, dA;
-    const unsigned A = info->a;
+    const int A = info->a;
 
     /* Set up some basic variables */
     dstbpp = dstfmt->BytesPerPixel;
@@ -380,12 +377,15 @@
             }
             bit = (byte & 0x80) >> 7;
             if (1) {
+                Uint32 pixel;
+                unsigned sR, sG, sB;
+                unsigned dR, dG, dB;
                 sR = srcpal[bit].r;
                 sG = srcpal[bit].g;
                 sB = srcpal[bit].b;
-                DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);
-                ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);
-                ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
+                DISEMBLE_RGB(dst, dstbpp, dstfmt, pixel, dR, dG, dB);
+                ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB);
+                ASSEMBLE_RGB(dst, dstbpp, dstfmt, dR, dG, dB);
             }
             byte <<= 1;
             dst += dstbpp;
@@ -409,10 +409,7 @@
     const SDL_Color *srcpal = srcfmt->palette->colors;
     int dstbpp;
     int c;
-    Uint32 pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB, dA;
-    const unsigned A = info->a;
+    const int A = info->a;
     Uint32 ckey = info->colorkey;
 
     /* Set up some basic variables */
@@ -427,12 +424,15 @@
             }
             bit = (byte & 0x80) >> 7;
             if (bit != ckey) {
+                int sR, sG, sB;
+                int dR, dG, dB;
+                Uint32 pixel;
                 sR = srcpal[bit].r;
                 sG = srcpal[bit].g;
                 sB = srcpal[bit].b;
-                DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);
-                ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);
-                ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
+                DISEMBLE_RGB(dst, dstbpp, dstfmt, pixel, dR, dG, dB);
+                ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB);
+                ASSEMBLE_RGB(dst, dstbpp, dstfmt, dR, dG, dB);
             }
             byte <<= 1;
             dst += dstbpp;
diff -ru SDL.orig/src/video/SDL_blit_1.c SDL/src/video/SDL_blit_1.c
--- SDL.orig/src/video/SDL_blit_1.c	2017-09-10 20:09:21.000000000 +0200
+++ SDL/src/video/SDL_blit_1.c	2017-09-16 15:26:40.000000000 +0200
@@ -437,29 +437,30 @@
     SDL_PixelFormat *dstfmt = info->dst_fmt;
     const SDL_Color *srcpal = info->src_fmt->palette->colors;
     int dstbpp;
-    Uint32 pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB, dA;
-    const unsigned A = info->a;
+    const int A = info->a;
 
     /* Set up some basic variables */
     dstbpp = dstfmt->BytesPerPixel;
 
     while (height--) {
-        /* *INDENT-OFF* */
-        DUFFS_LOOP4(
-        {
-            sR = srcpal[*src].r;
-            sG = srcpal[*src].g;
-            sB = srcpal[*src].b;
-            DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);
-            ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);
-            ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
-            src++;
-            dst += dstbpp;
-        },
-        width);
-        /* *INDENT-ON* */
+        int sR, sG, sB;
+        int dR, dG, dB;
+	    	/* *INDENT-OFF* */
+	    	DUFFS_LOOP4(
+			{
+			        Uint32 pixel;
+				sR = srcpal[*src].r;
+				sG = srcpal[*src].g;
+				sB = srcpal[*src].b;
+				DISEMBLE_RGB(dst, dstbpp, dstfmt,
+					     pixel, dR, dG, dB);
+				ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB);
+			  	ASSEMBLE_RGB(dst, dstbpp, dstfmt, dR, dG, dB);
+				src++;
+				dst += dstbpp;
+			},
+			width);
+	    	/* *INDENT-ON* */
         src += srcskip;
         dst += dstskip;
     }
@@ -478,25 +479,26 @@
     const SDL_Color *srcpal = info->src_fmt->palette->colors;
     Uint32 ckey = info->colorkey;
     int dstbpp;
-    Uint32 pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB, dA;
-    const unsigned A = info->a;
+    const int A = info->a;
 
     /* Set up some basic variables */
     dstbpp = dstfmt->BytesPerPixel;
 
     while (height--) {
+        int sR, sG, sB;
+        int dR, dG, dB;
 		/* *INDENT-OFF* */
 		DUFFS_LOOP(
 		{
 			if ( *src != ckey ) {
+			        Uint32 pixel;
 				sR = srcpal[*src].r;
 				sG = srcpal[*src].g;
 				sB = srcpal[*src].b;
-				DISEMBLE_RGBA(dst, dstbpp, dstfmt, pixel, dR, dG, dB, dA);
-				ALPHA_BLEND_RGBA(sR, sG, sB, A, dR, dG, dB, dA);
-			  	ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
+				DISEMBLE_RGB(dst, dstbpp, dstfmt,
+							pixel, dR, dG, dB);
+				ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB);
+			  	ASSEMBLE_RGB(dst, dstbpp, dstfmt, dR, dG, dB);
 			}
 			src++;
 			dst += dstbpp;
diff -ru SDL.orig/src/video/SDL_blit_A.c SDL/src/video/SDL_blit_A.c
--- SDL.orig/src/video/SDL_blit_A.c	2017-09-10 20:09:21.000000000 +0200
+++ SDL/src/video/SDL_blit_A.c	2017-09-16 15:26:40.000000000 +0200
@@ -39,28 +39,37 @@
     SDL_PixelFormat *srcfmt = info->src_fmt;
     SDL_PixelFormat *dstfmt = info->dst_fmt;
     int srcbpp = srcfmt->BytesPerPixel;
-    Uint32 Pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB;
+
     const unsigned A = info->a;
 
     while (height--) {
 	    /* *INDENT-OFF* */
 	    DUFFS_LOOP4(
 	    {
+		Uint32 Pixel;
+		unsigned sR;
+		unsigned sG;
+		unsigned sB;
+		unsigned dR;
+		unsigned dG;
+		unsigned dB;
 		DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);
 		dR = dstfmt->palette->colors[*dst].r;
 		dG = dstfmt->palette->colors[*dst].g;
 		dB = dstfmt->palette->colors[*dst].b;
-		ALPHA_BLEND_RGB(sR, sG, sB, A, dR, dG, dB);
+		ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB);
 		dR &= 0xff;
 		dG &= 0xff;
 		dB &= 0xff;
 		/* Pack RGB into 8bit pixel */
 		if ( palmap == NULL ) {
-		    *dst =((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0));
+		    *dst =((dR>>5)<<(3+2))|
+			  ((dG>>5)<<(2))|
+			  ((dB>>6)<<(0));
 		} else {
-		    *dst = palmap[((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0))];
+		    *dst = palmap[((dR>>5)<<(3+2))|
+				  ((dG>>5)<<(2))  |
+				  ((dB>>6)<<(0))];
 		}
 		dst++;
 		src += srcbpp;
@@ -86,27 +95,36 @@
     SDL_PixelFormat *srcfmt = info->src_fmt;
     SDL_PixelFormat *dstfmt = info->dst_fmt;
     int srcbpp = srcfmt->BytesPerPixel;
-    Uint32 Pixel;
-    unsigned sR, sG, sB, sA;
-    unsigned dR, dG, dB;
 
     while (height--) {
 	    /* *INDENT-OFF* */
 	    DUFFS_LOOP4(
 	    {
+		Uint32 Pixel;
+		unsigned sR;
+		unsigned sG;
+		unsigned sB;
+		unsigned sA;
+		unsigned dR;
+		unsigned dG;
+		unsigned dB;
 		DISEMBLE_RGBA(src,srcbpp,srcfmt,Pixel,sR,sG,sB,sA);
 		dR = dstfmt->palette->colors[*dst].r;
 		dG = dstfmt->palette->colors[*dst].g;
 		dB = dstfmt->palette->colors[*dst].b;
-		ALPHA_BLEND_RGB(sR, sG, sB, sA, dR, dG, dB);
+		ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB);
 		dR &= 0xff;
 		dG &= 0xff;
 		dB &= 0xff;
 		/* Pack RGB into 8bit pixel */
 		if ( palmap == NULL ) {
-		    *dst =((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0));
+		    *dst =((dR>>5)<<(3+2))|
+			  ((dG>>5)<<(2))|
+			  ((dB>>6)<<(0));
 		} else {
-		    *dst = palmap[((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0))];
+		    *dst = palmap[((dR>>5)<<(3+2))|
+				  ((dG>>5)<<(2))  |
+				  ((dB>>6)<<(0))  ];
 		}
 		dst++;
 		src += srcbpp;
@@ -133,29 +151,38 @@
     SDL_PixelFormat *dstfmt = info->dst_fmt;
     int srcbpp = srcfmt->BytesPerPixel;
     Uint32 ckey = info->colorkey;
-    Uint32 Pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB;
-    const unsigned A = info->a;
+
+    const int A = info->a;
 
     while (height--) {
 	    /* *INDENT-OFF* */
 	    DUFFS_LOOP(
 	    {
+		Uint32 Pixel;
+		unsigned sR;
+		unsigned sG;
+		unsigned sB;
+		unsigned dR;
+		unsigned dG;
+		unsigned dB;
 		DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);
 		if ( Pixel != ckey ) {
 		    dR = dstfmt->palette->colors[*dst].r;
 		    dG = dstfmt->palette->colors[*dst].g;
 		    dB = dstfmt->palette->colors[*dst].b;
-		    ALPHA_BLEND_RGB(sR, sG, sB, A, dR, dG, dB);
+		    ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB);
 		    dR &= 0xff;
 		    dG &= 0xff;
 		    dB &= 0xff;
 		    /* Pack RGB into 8bit pixel */
 		    if ( palmap == NULL ) {
-                *dst =((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0));
+			*dst =((dR>>5)<<(3+2))|
+			      ((dG>>5)<<(2)) |
+			      ((dB>>6)<<(0));
 		    } else {
-                *dst = palmap[((dR>>5)<<(3+2))|((dG>>5)<<(2))|((dB>>6)<<(0))];
+			*dst = palmap[((dR>>5)<<(3+2))|
+				      ((dG>>5)<<(2))  |
+				      ((dB>>6)<<(0))  ];
 		    }
 		}
 		dst++;
@@ -389,6 +416,807 @@
 
 #endif /* __MMX__ */
 
+#if SDL_ALTIVEC_BLITTERS
+#if __MWERKS__
+#pragma altivec_model on
+#endif
+#if HAVE_ALTIVEC_H
+#include <altivec.h>
+#endif
+
+#if (defined(__MACOSX__) && (__GNUC__ < 4))
+#define VECUINT8_LITERAL(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
+        (vector unsigned char) ( a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p )
+#define VECUINT16_LITERAL(a,b,c,d,e,f,g,h) \
+        (vector unsigned short) ( a,b,c,d,e,f,g,h )
+#else
+#define VECUINT8_LITERAL(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
+        (vector unsigned char) { a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p }
+#define VECUINT16_LITERAL(a,b,c,d,e,f,g,h) \
+        (vector unsigned short) { a,b,c,d,e,f,g,h }
+#endif
+
+#define UNALIGNED_PTR(x) (((size_t) x) & 0x0000000F)
+#define VECPRINT(msg, v) do { \
+    vector unsigned int tmpvec = (vector unsigned int)(v); \
+    unsigned int *vp = (unsigned int *)&tmpvec; \
+    printf("%s = %08X %08X %08X %08X\n", msg, vp[0], vp[1], vp[2], vp[3]); \
+} while (0)
+
+/* the permuation vector that takes the high bytes out of all the appropriate shorts 
+    (vector unsigned char)(
+        0x00, 0x10, 0x02, 0x12,
+        0x04, 0x14, 0x06, 0x16,
+        0x08, 0x18, 0x0A, 0x1A,
+        0x0C, 0x1C, 0x0E, 0x1E );
+*/
+#define VEC_MERGE_PERMUTE() (vec_add(vec_lvsl(0, (int*)NULL), (vector unsigned char)vec_splat_u16(0x0F)))
+#define VEC_U32_24() (vec_add(vec_splat_u32(12), vec_splat_u32(12)))
+#define VEC_ALPHA_MASK() ((vector unsigned char)vec_sl((vector unsigned int)vec_splat_s8(-1), VEC_U32_24()))
+#define VEC_ALIGNER(src) ((UNALIGNED_PTR(src)) \
+    ? vec_lvsl(0, src) \
+    : vec_add(vec_lvsl(8, src), vec_splat_u8(8)))
+
+
+#define VEC_MULTIPLY_ALPHA(vs, vd, valpha, mergePermute, v1_16, v8_16) do { \
+    /* vtemp1 contains source AAGGAAGGAAGGAAGG */ \
+    vector unsigned short vtemp1 = vec_mule(vs, valpha); \
+    /* vtemp2 contains source RRBBRRBBRRBBRRBB */ \
+    vector unsigned short vtemp2 = vec_mulo(vs, valpha); \
+    /* valpha2 is 255-alpha */ \
+    vector unsigned char valpha2 = vec_nor(valpha, valpha); \
+    /* vtemp3 contains dest AAGGAAGGAAGGAAGG */ \
+    vector unsigned short vtemp3 = vec_mule(vd, valpha2); \
+    /* vtemp4 contains dest RRBBRRBBRRBBRRBB */ \
+    vector unsigned short vtemp4 = vec_mulo(vd, valpha2); \
+    /* add source and dest */ \
+    vtemp1 = vec_add(vtemp1, vtemp3); \
+    vtemp2 = vec_add(vtemp2, vtemp4); \
+    /* vtemp1 = (vtemp1 + 1) + ((vtemp1 + 1) >> 8) */ \
+    vtemp1 = vec_add(vtemp1, v1_16); \
+    vtemp3 = vec_sr(vtemp1, v8_16); \
+    vtemp1 = vec_add(vtemp1, vtemp3); \
+    /* vtemp2 = (vtemp2 + 1) + ((vtemp2 + 1) >> 8) */ \
+    vtemp2 = vec_add(vtemp2, v1_16); \
+    vtemp4 = vec_sr(vtemp2, v8_16); \
+    vtemp2 = vec_add(vtemp2, vtemp4); \
+    /* (>>8) and get ARGBARGBARGBARGB */ \
+    vd = (vector unsigned char)vec_perm(vtemp1, vtemp2, mergePermute); \
+} while (0)
+
+/* Calculate the permute vector used for 32->32 swizzling */
+static vector unsigned char
+calc_swizzle32(const SDL_PixelFormat * srcfmt, const SDL_PixelFormat * dstfmt)
+{
+    /*
+     * We have to assume that the bits that aren't used by other
+     *  colors is alpha, and it's one complete byte, since some formats
+     *  leave alpha with a zero mask, but we should still swizzle the bits.
+     */
+    /* ARGB */
+    const static struct SDL_PixelFormat default_pixel_format = {
+        0, NULL, 0, 0,
+        {0, 0},
+        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
+        0, 0, 0, 0,
+        16, 8, 0, 24,
+        0, NULL
+    };
+    if (!srcfmt) {
+        srcfmt = &default_pixel_format;
+    }
+    if (!dstfmt) {
+        dstfmt = &default_pixel_format;
+    }
+    const vector unsigned char plus = VECUINT8_LITERAL(0x00, 0x00, 0x00, 0x00,
+                                                       0x04, 0x04, 0x04, 0x04,
+                                                       0x08, 0x08, 0x08, 0x08,
+                                                       0x0C, 0x0C, 0x0C,
+                                                       0x0C);
+    vector unsigned char vswiz;
+    vector unsigned int srcvec;
+#define RESHIFT(X) (3 - ((X) >> 3))
+    Uint32 rmask = RESHIFT(srcfmt->Rshift) << (dstfmt->Rshift);
+    Uint32 gmask = RESHIFT(srcfmt->Gshift) << (dstfmt->Gshift);
+    Uint32 bmask = RESHIFT(srcfmt->Bshift) << (dstfmt->Bshift);
+    Uint32 amask;
+    /* Use zero for alpha if either surface doesn't have alpha */
+    if (dstfmt->Amask) {
+        amask =
+            ((srcfmt->Amask) ? RESHIFT(srcfmt->
+                                       Ashift) : 0x10) << (dstfmt->Ashift);
+    } else {
+        amask =
+            0x10101010 & ((dstfmt->Rmask | dstfmt->Gmask | dstfmt->Bmask) ^
+                          0xFFFFFFFF);
+    }
+#undef RESHIFT
+    ((unsigned int *) (char *) &srcvec)[0] = (rmask | gmask | bmask | amask);
+    vswiz = vec_add(plus, (vector unsigned char) vec_splat(srcvec, 0));
+    return (vswiz);
+}
+
+static void
+Blit32to565PixelAlphaAltivec(SDL_BlitInfo * info)
+{
+    int height = info->dst_h;
+    Uint8 *src = (Uint8 *) info->src;
+    int srcskip = info->src_skip;
+    Uint8 *dst = (Uint8 *) info->dst;
+    int dstskip = info->dst_skip;
+    SDL_PixelFormat *srcfmt = info->src_fmt;
+
+    vector unsigned char v0 = vec_splat_u8(0);
+    vector unsigned short v8_16 = vec_splat_u16(8);
+    vector unsigned short v1_16 = vec_splat_u16(1);
+    vector unsigned short v2_16 = vec_splat_u16(2);
+    vector unsigned short v3_16 = vec_splat_u16(3);
+    vector unsigned int v8_32 = vec_splat_u32(8);
+    vector unsigned int v16_32 = vec_add(v8_32, v8_32);
+    vector unsigned short v3f =
+        VECUINT16_LITERAL(0x003f, 0x003f, 0x003f, 0x003f,
+                          0x003f, 0x003f, 0x003f, 0x003f);
+    vector unsigned short vfc =
+        VECUINT16_LITERAL(0x00fc, 0x00fc, 0x00fc, 0x00fc,
+                          0x00fc, 0x00fc, 0x00fc, 0x00fc);
+
+    /* 
+       0x10 - 0x1f is the alpha
+       0x00 - 0x0e evens are the red
+       0x01 - 0x0f odds are zero
+     */
+    vector unsigned char vredalpha1 = VECUINT8_LITERAL(0x10, 0x00, 0x01, 0x01,
+                                                       0x10, 0x02, 0x01, 0x01,
+                                                       0x10, 0x04, 0x01, 0x01,
+                                                       0x10, 0x06, 0x01,
+                                                       0x01);
+    vector unsigned char vredalpha2 =
+        (vector unsigned char) (vec_add((vector unsigned int) vredalpha1,
+                                        vec_sl(v8_32, v16_32))
+        );
+    /*
+       0x00 - 0x0f is ARxx ARxx ARxx ARxx
+       0x11 - 0x0f odds are blue
+     */
+    vector unsigned char vblue1 = VECUINT8_LITERAL(0x00, 0x01, 0x02, 0x11,
+                                                   0x04, 0x05, 0x06, 0x13,
+                                                   0x08, 0x09, 0x0a, 0x15,
+                                                   0x0c, 0x0d, 0x0e, 0x17);
+    vector unsigned char vblue2 =
+        (vector unsigned char) (vec_add((vector unsigned int) vblue1, v8_32)
+        );
+    /*
+       0x00 - 0x0f is ARxB ARxB ARxB ARxB
+       0x10 - 0x0e evens are green
+     */
+    vector unsigned char vgreen1 = VECUINT8_LITERAL(0x00, 0x01, 0x10, 0x03,
+                                                    0x04, 0x05, 0x12, 0x07,
+                                                    0x08, 0x09, 0x14, 0x0b,
+                                                    0x0c, 0x0d, 0x16, 0x0f);
+    vector unsigned char vgreen2 =
+        (vector unsigned
+         char) (vec_add((vector unsigned int) vgreen1, vec_sl(v8_32, v8_32))
+        );
+    vector unsigned char vgmerge = VECUINT8_LITERAL(0x00, 0x02, 0x00, 0x06,
+                                                    0x00, 0x0a, 0x00, 0x0e,
+                                                    0x00, 0x12, 0x00, 0x16,
+                                                    0x00, 0x1a, 0x00, 0x1e);
+    vector unsigned char mergePermute = VEC_MERGE_PERMUTE();
+    vector unsigned char vpermute = calc_swizzle32(srcfmt, NULL);
+    vector unsigned char valphaPermute =
+        vec_and(vec_lvsl(0, (int *) NULL), vec_splat_u8(0xC));
+
+    vector unsigned short vf800 = (vector unsigned short) vec_splat_u8(-7);
+    vf800 = vec_sl(vf800, vec_splat_u16(8));
+
+    while (height--) {
+        int extrawidth;
+        vector unsigned char valigner;
+        vector unsigned char vsrc;
+        vector unsigned char voverflow;
+        int width = info->dst_w;
+
+#define ONE_PIXEL_BLEND(condition, widthvar) \
+        while (condition) { \
+            Uint32 Pixel; \
+            unsigned sR, sG, sB, dR, dG, dB, sA; \
+            DISEMBLE_RGBA(src, 4, srcfmt, Pixel, sR, sG, sB, sA); \
+            if(sA) { \
+                unsigned short dstpixel = *((unsigned short *)dst); \
+                dR = (dstpixel >> 8) & 0xf8; \
+                dG = (dstpixel >> 3) & 0xfc; \
+                dB = (dstpixel << 3) & 0xf8; \
+                ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB); \
+                *((unsigned short *)dst) = ( \
+                    ((dR & 0xf8) << 8) | ((dG & 0xfc) << 3) | (dB >> 3) \
+                ); \
+            } \
+            src += 4; \
+            dst += 2; \
+            widthvar--; \
+        }
+        ONE_PIXEL_BLEND((UNALIGNED_PTR(dst)) && (width), width);
+        extrawidth = (width % 8);
+        valigner = VEC_ALIGNER(src);
+        vsrc = (vector unsigned char) vec_ld(0, src);
+        width -= extrawidth;
+        while (width) {
+            vector unsigned char valpha;
+            vector unsigned char vsrc1, vsrc2;
+            vector unsigned char vdst1, vdst2;
+            vector unsigned short vR, vG, vB;
+            vector unsigned short vpixel, vrpixel, vgpixel, vbpixel;
+
+            /* Load 8 pixels from src as ARGB */
+            voverflow = (vector unsigned char) vec_ld(15, src);
+            vsrc = vec_perm(vsrc, voverflow, valigner);
+            vsrc1 = vec_perm(vsrc, vsrc, vpermute);
+            src += 16;
+            vsrc = (vector unsigned char) vec_ld(15, src);
+            voverflow = vec_perm(voverflow, vsrc, valigner);
+            vsrc2 = vec_perm(voverflow, voverflow, vpermute);
+            src += 16;
+
+            /* Load 8 pixels from dst as XRGB */
+            voverflow = vec_ld(0, dst);
+            vR = vec_and((vector unsigned short) voverflow, vf800);
+            vB = vec_sl((vector unsigned short) voverflow, v3_16);
+            vG = vec_sl(vB, v2_16);
+            vdst1 =
+                (vector unsigned char) vec_perm((vector unsigned char) vR,
+                                                (vector unsigned char) vR,
+                                                vredalpha1);
+            vdst1 = vec_perm(vdst1, (vector unsigned char) vB, vblue1);
+            vdst1 = vec_perm(vdst1, (vector unsigned char) vG, vgreen1);
+            vdst2 =
+                (vector unsigned char) vec_perm((vector unsigned char) vR,
+                                                (vector unsigned char) vR,
+                                                vredalpha2);
+            vdst2 = vec_perm(vdst2, (vector unsigned char) vB, vblue2);
+            vdst2 = vec_perm(vdst2, (vector unsigned char) vG, vgreen2);
+
+            /* Alpha blend 8 pixels as ARGB */
+            valpha = vec_perm(vsrc1, v0, valphaPermute);
+            VEC_MULTIPLY_ALPHA(vsrc1, vdst1, valpha, mergePermute, v1_16,
+                               v8_16);
+            valpha = vec_perm(vsrc2, v0, valphaPermute);
+            VEC_MULTIPLY_ALPHA(vsrc2, vdst2, valpha, mergePermute, v1_16,
+                               v8_16);
+
+            /* Convert 8 pixels to 565 */
+            vpixel = (vector unsigned short) vec_packpx((vector unsigned int)
+                                                        vdst1,
+                                                        (vector unsigned int)
+                                                        vdst2);
+            vgpixel = (vector unsigned short) vec_perm(vdst1, vdst2, vgmerge);
+            vgpixel = vec_and(vgpixel, vfc);
+            vgpixel = vec_sl(vgpixel, v3_16);
+            vrpixel = vec_sl(vpixel, v1_16);
+            vrpixel = vec_and(vrpixel, vf800);
+            vbpixel = vec_and(vpixel, v3f);
+            vdst1 =
+                vec_or((vector unsigned char) vrpixel,
+                       (vector unsigned char) vgpixel);
+            vdst1 = vec_or(vdst1, (vector unsigned char) vbpixel);
+
+            /* Store 8 pixels */
+            vec_st(vdst1, 0, dst);
+
+            width -= 8;
+            dst += 16;
+        }
+        ONE_PIXEL_BLEND((extrawidth), extrawidth);
+#undef ONE_PIXEL_BLEND
+        src += srcskip;
+        dst += dstskip;
+    }
+}
+
+static void
+Blit32to32SurfaceAlphaKeyAltivec(SDL_BlitInfo * info)
+{
+    int height = info->dst_h;
+    Uint32 *srcp = (Uint32 *) info->src;
+    int srcskip = info->src_skip >> 2;
+    Uint32 *dstp = (Uint32 *) info->dst;
+    int dstskip = info->dst_skip >> 2;
+    SDL_PixelFormat *srcfmt = info->src_fmt;
+    SDL_PixelFormat *dstfmt = info->dst_fmt;
+    unsigned sA = info->a;
+    unsigned dA = dstfmt->Amask ? SDL_ALPHA_OPAQUE : 0;
+    Uint32 rgbmask = srcfmt->Rmask | srcfmt->Gmask | srcfmt->Bmask;
+    Uint32 ckey = info->colorkey;
+    vector unsigned char mergePermute;
+    vector unsigned char vsrcPermute;
+    vector unsigned char vdstPermute;
+    vector unsigned char vsdstPermute;
+    vector unsigned char valpha;
+    vector unsigned char valphamask;
+    vector unsigned char vbits;
+    vector unsigned char v0;
+    vector unsigned short v1;
+    vector unsigned short v8;
+    vector unsigned int vckey;
+    vector unsigned int vrgbmask;
+
+    mergePermute = VEC_MERGE_PERMUTE();
+    v0 = vec_splat_u8(0);
+    v1 = vec_splat_u16(1);
+    v8 = vec_splat_u16(8);
+
+    /* set the alpha to 255 on the destination surf */
+    valphamask = VEC_ALPHA_MASK();
+
+    vsrcPermute = calc_swizzle32(srcfmt, NULL);
+    vdstPermute = calc_swizzle32(NULL, dstfmt);
+    vsdstPermute = calc_swizzle32(dstfmt, NULL);
+
+    /* set a vector full of alpha and 255-alpha */
+    ((unsigned char *) &valpha)[0] = sA;
+    valpha = vec_splat(valpha, 0);
+    vbits = (vector unsigned char) vec_splat_s8(-1);
+
+    ckey &= rgbmask;
+    ((unsigned int *) (char *) &vckey)[0] = ckey;
+    vckey = vec_splat(vckey, 0);
+    ((unsigned int *) (char *) &vrgbmask)[0] = rgbmask;
+    vrgbmask = vec_splat(vrgbmask, 0);
+
+    while (height--) {
+        int width = info->dst_w;
+#define ONE_PIXEL_BLEND(condition, widthvar) \
+        while (condition) { \
+            Uint32 Pixel; \
+            unsigned sR, sG, sB, dR, dG, dB; \
+            RETRIEVE_RGB_PIXEL(((Uint8 *)srcp), 4, Pixel); \
+            if(sA && Pixel != ckey) { \
+                RGB_FROM_PIXEL(Pixel, srcfmt, sR, sG, sB); \
+                DISEMBLE_RGB(((Uint8 *)dstp), 4, dstfmt, Pixel, dR, dG, dB); \
+                ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB); \
+                ASSEMBLE_RGBA(((Uint8 *)dstp), 4, dstfmt, dR, dG, dB, dA); \
+            } \
+            dstp++; \
+            srcp++; \
+            widthvar--; \
+        }
+        ONE_PIXEL_BLEND((UNALIGNED_PTR(dstp)) && (width), width);
+        if (width > 0) {
+            int extrawidth = (width % 4);
+            vector unsigned char valigner = VEC_ALIGNER(srcp);
+            vector unsigned char vs = (vector unsigned char) vec_ld(0, srcp);
+            width -= extrawidth;
+            while (width) {
+                vector unsigned char vsel;
+                vector unsigned char voverflow;
+                vector unsigned char vd;
+                vector unsigned char vd_orig;
+
+                /* s = *srcp */
+                voverflow = (vector unsigned char) vec_ld(15, srcp);
+                vs = vec_perm(vs, voverflow, valigner);
+
+                /* vsel is set for items that match the key */
+                vsel =
+                    (vector unsigned char) vec_and((vector unsigned int) vs,
+                                                   vrgbmask);
+                vsel = (vector unsigned char) vec_cmpeq((vector unsigned int)
+                                                        vsel, vckey);
+
+                /* permute to source format */
+                vs = vec_perm(vs, valpha, vsrcPermute);
+
+                /* d = *dstp */
+                vd = (vector unsigned char) vec_ld(0, dstp);
+                vd_orig = vd = vec_perm(vd, v0, vsdstPermute);
+
+                VEC_MULTIPLY_ALPHA(vs, vd, valpha, mergePermute, v1, v8);
+
+                /* set the alpha channel to full on */
+                vd = vec_or(vd, valphamask);
+
+                /* mask out color key */
+                vd = vec_sel(vd, vd_orig, vsel);
+
+                /* permute to dest format */
+                vd = vec_perm(vd, vbits, vdstPermute);
+
+                /* *dstp = res */
+                vec_st((vector unsigned int) vd, 0, dstp);
+
+                srcp += 4;
+                dstp += 4;
+                width -= 4;
+                vs = voverflow;
+            }
+            ONE_PIXEL_BLEND((extrawidth), extrawidth);
+        }
+#undef ONE_PIXEL_BLEND
+
+        srcp += srcskip;
+        dstp += dstskip;
+    }
+}
+
+
+static void
+Blit32to32PixelAlphaAltivec(SDL_BlitInfo * info)
+{
+    int width = info->dst_w;
+    int height = info->dst_h;
+    Uint32 *srcp = (Uint32 *) info->src;
+    int srcskip = info->src_skip >> 2;
+    Uint32 *dstp = (Uint32 *) info->dst;
+    int dstskip = info->dst_skip >> 2;
+    SDL_PixelFormat *srcfmt = info->src_fmt;
+    SDL_PixelFormat *dstfmt = info->dst_fmt;
+    vector unsigned char mergePermute;
+    vector unsigned char valphaPermute;
+    vector unsigned char vsrcPermute;
+    vector unsigned char vdstPermute;
+    vector unsigned char vsdstPermute;
+    vector unsigned char valphamask;
+    vector unsigned char vpixelmask;
+    vector unsigned char v0;
+    vector unsigned short v1;
+    vector unsigned short v8;
+
+    v0 = vec_splat_u8(0);
+    v1 = vec_splat_u16(1);
+    v8 = vec_splat_u16(8);
+    mergePermute = VEC_MERGE_PERMUTE();
+    valphamask = VEC_ALPHA_MASK();
+    valphaPermute = vec_and(vec_lvsl(0, (int *) NULL), vec_splat_u8(0xC));
+    vpixelmask = vec_nor(valphamask, v0);
+    vsrcPermute = calc_swizzle32(srcfmt, NULL);
+    vdstPermute = calc_swizzle32(NULL, dstfmt);
+    vsdstPermute = calc_swizzle32(dstfmt, NULL);
+
+    while (height--) {
+        width = info->dst_w;
+#define ONE_PIXEL_BLEND(condition, widthvar) while ((condition)) { \
+            Uint32 Pixel; \
+            unsigned sR, sG, sB, dR, dG, dB, sA, dA; \
+            DISEMBLE_RGBA((Uint8 *)srcp, 4, srcfmt, Pixel, sR, sG, sB, sA); \
+            if(sA) { \
+              DISEMBLE_RGBA((Uint8 *)dstp, 4, dstfmt, Pixel, dR, dG, dB, dA); \
+              ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB); \
+              ASSEMBLE_RGBA((Uint8 *)dstp, 4, dstfmt, dR, dG, dB, dA); \
+            } \
+            ++srcp; \
+            ++dstp; \
+            widthvar--; \
+        }
+        ONE_PIXEL_BLEND((UNALIGNED_PTR(dstp)) && (width), width);
+        if (width > 0) {
+            /* vsrcPermute */
+            /* vdstPermute */
+            int extrawidth = (width % 4);
+            vector unsigned char valigner = VEC_ALIGNER(srcp);
+            vector unsigned char vs = (vector unsigned char) vec_ld(0, srcp);
+            width -= extrawidth;
+            while (width) {
+                vector unsigned char voverflow;
+                vector unsigned char vd;
+                vector unsigned char valpha;
+                vector unsigned char vdstalpha;
+                /* s = *srcp */
+                voverflow = (vector unsigned char) vec_ld(15, srcp);
+                vs = vec_perm(vs, voverflow, valigner);
+                vs = vec_perm(vs, v0, vsrcPermute);
+
+                valpha = vec_perm(vs, v0, valphaPermute);
+
+                /* d = *dstp */
+                vd = (vector unsigned char) vec_ld(0, dstp);
+                vd = vec_perm(vd, v0, vsdstPermute);
+                vdstalpha = vec_and(vd, valphamask);
+
+                VEC_MULTIPLY_ALPHA(vs, vd, valpha, mergePermute, v1, v8);
+
+                /* set the alpha to the dest alpha */
+                vd = vec_and(vd, vpixelmask);
+                vd = vec_or(vd, vdstalpha);
+                vd = vec_perm(vd, v0, vdstPermute);
+
+                /* *dstp = res */
+                vec_st((vector unsigned int) vd, 0, dstp);
+
+                srcp += 4;
+                dstp += 4;
+                width -= 4;
+                vs = voverflow;
+
+            }
+            ONE_PIXEL_BLEND((extrawidth), extrawidth);
+        }
+        srcp += srcskip;
+        dstp += dstskip;
+#undef ONE_PIXEL_BLEND
+    }
+}
+
+/* fast ARGB888->(A)RGB888 blending with pixel alpha */
+static void
+BlitRGBtoRGBPixelAlphaAltivec(SDL_BlitInfo * info)
+{
+    int width = info->dst_w;
+    int height = info->dst_h;
+    Uint32 *srcp = (Uint32 *) info->src;
+    int srcskip = info->src_skip >> 2;
+    Uint32 *dstp = (Uint32 *) info->dst;
+    int dstskip = info->dst_skip >> 2;
+    vector unsigned char mergePermute;
+    vector unsigned char valphaPermute;
+    vector unsigned char valphamask;
+    vector unsigned char vpixelmask;
+    vector unsigned char v0;
+    vector unsigned short v1;
+    vector unsigned short v8;
+    v0 = vec_splat_u8(0);
+    v1 = vec_splat_u16(1);
+    v8 = vec_splat_u16(8);
+    mergePermute = VEC_MERGE_PERMUTE();
+    valphamask = VEC_ALPHA_MASK();
+    valphaPermute = vec_and(vec_lvsl(0, (int *) NULL), vec_splat_u8(0xC));
+
+
+    vpixelmask = vec_nor(valphamask, v0);
+    while (height--) {
+        width = info->dst_w;
+#define ONE_PIXEL_BLEND(condition, widthvar) \
+        while ((condition)) { \
+            Uint32 dalpha; \
+            Uint32 d; \
+            Uint32 s1; \
+            Uint32 d1; \
+            Uint32 s = *srcp; \
+            Uint32 alpha = s >> 24; \
+            if(alpha) { \
+              if(alpha == SDL_ALPHA_OPAQUE) { \
+                *dstp = (s & 0x00ffffff) | (*dstp & 0xff000000); \
+              } else { \
+                d = *dstp; \
+                dalpha = d & 0xff000000; \
+                s1 = s & 0xff00ff; \
+                d1 = d & 0xff00ff; \
+                d1 = (d1 + ((s1 - d1) * alpha >> 8)) & 0xff00ff; \
+                s &= 0xff00; \
+                d &= 0xff00; \
+                d = (d + ((s - d) * alpha >> 8)) & 0xff00; \
+                *dstp = d1 | d | dalpha; \
+              } \
+            } \
+            ++srcp; \
+            ++dstp; \
+            widthvar--; \
+	    }
+        ONE_PIXEL_BLEND((UNALIGNED_PTR(dstp)) && (width), width);
+        if (width > 0) {
+            int extrawidth = (width % 4);
+            vector unsigned char valigner = VEC_ALIGNER(srcp);
+            vector unsigned char vs = (vector unsigned char) vec_ld(0, srcp);
+            width -= extrawidth;
+            while (width) {
+                vector unsigned char voverflow;
+                vector unsigned char vd;
+                vector unsigned char valpha;
+                vector unsigned char vdstalpha;
+                /* s = *srcp */
+                voverflow = (vector unsigned char) vec_ld(15, srcp);
+                vs = vec_perm(vs, voverflow, valigner);
+
+                valpha = vec_perm(vs, v0, valphaPermute);
+
+                /* d = *dstp */
+                vd = (vector unsigned char) vec_ld(0, dstp);
+                vdstalpha = vec_and(vd, valphamask);
+
+                VEC_MULTIPLY_ALPHA(vs, vd, valpha, mergePermute, v1, v8);
+
+                /* set the alpha to the dest alpha */
+                vd = vec_and(vd, vpixelmask);
+                vd = vec_or(vd, vdstalpha);
+
+                /* *dstp = res */
+                vec_st((vector unsigned int) vd, 0, dstp);
+
+                srcp += 4;
+                dstp += 4;
+                width -= 4;
+                vs = voverflow;
+            }
+            ONE_PIXEL_BLEND((extrawidth), extrawidth);
+        }
+        srcp += srcskip;
+        dstp += dstskip;
+    }
+#undef ONE_PIXEL_BLEND
+}
+
+static void
+Blit32to32SurfaceAlphaAltivec(SDL_BlitInfo * info)
+{
+    /* XXX : 6 */
+    int height = info->dst_h;
+    Uint32 *srcp = (Uint32 *) info->src;
+    int srcskip = info->src_skip >> 2;
+    Uint32 *dstp = (Uint32 *) info->dst;
+    int dstskip = info->dst_skip >> 2;
+    SDL_PixelFormat *srcfmt = info->src_fmt;
+    SDL_PixelFormat *dstfmt = info->dst_fmt;
+    unsigned sA = info->a;
+    unsigned dA = dstfmt->Amask ? SDL_ALPHA_OPAQUE : 0;
+    vector unsigned char mergePermute;
+    vector unsigned char vsrcPermute;
+    vector unsigned char vdstPermute;
+    vector unsigned char vsdstPermute;
+    vector unsigned char valpha;
+    vector unsigned char valphamask;
+    vector unsigned char vbits;
+    vector unsigned short v1;
+    vector unsigned short v8;
+
+    mergePermute = VEC_MERGE_PERMUTE();
+    v1 = vec_splat_u16(1);
+    v8 = vec_splat_u16(8);
+
+    /* set the alpha to 255 on the destination surf */
+    valphamask = VEC_ALPHA_MASK();
+
+    vsrcPermute = calc_swizzle32(srcfmt, NULL);
+    vdstPermute = calc_swizzle32(NULL, dstfmt);
+    vsdstPermute = calc_swizzle32(dstfmt, NULL);
+
+    /* set a vector full of alpha and 255-alpha */
+    ((unsigned char *) &valpha)[0] = sA;
+    valpha = vec_splat(valpha, 0);
+    vbits = (vector unsigned char) vec_splat_s8(-1);
+
+    while (height--) {
+        int width = info->dst_w;
+#define ONE_PIXEL_BLEND(condition, widthvar) while ((condition)) { \
+            Uint32 Pixel; \
+            unsigned sR, sG, sB, dR, dG, dB; \
+            DISEMBLE_RGB(((Uint8 *)srcp), 4, srcfmt, Pixel, sR, sG, sB); \
+            DISEMBLE_RGB(((Uint8 *)dstp), 4, dstfmt, Pixel, dR, dG, dB); \
+            ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB); \
+            ASSEMBLE_RGBA(((Uint8 *)dstp), 4, dstfmt, dR, dG, dB, dA); \
+            ++srcp; \
+            ++dstp; \
+            widthvar--; \
+        }
+        ONE_PIXEL_BLEND((UNALIGNED_PTR(dstp)) && (width), width);
+        if (width > 0) {
+            int extrawidth = (width % 4);
+            vector unsigned char valigner = VEC_ALIGNER(srcp);
+            vector unsigned char vs = (vector unsigned char) vec_ld(0, srcp);
+            width -= extrawidth;
+            while (width) {
+                vector unsigned char voverflow;
+                vector unsigned char vd;
+
+                /* s = *srcp */
+                voverflow = (vector unsigned char) vec_ld(15, srcp);
+                vs = vec_perm(vs, voverflow, valigner);
+                vs = vec_perm(vs, valpha, vsrcPermute);
+
+                /* d = *dstp */
+                vd = (vector unsigned char) vec_ld(0, dstp);
+                vd = vec_perm(vd, vd, vsdstPermute);
+
+                VEC_MULTIPLY_ALPHA(vs, vd, valpha, mergePermute, v1, v8);
+
+                /* set the alpha channel to full on */
+                vd = vec_or(vd, valphamask);
+                vd = vec_perm(vd, vbits, vdstPermute);
+
+                /* *dstp = res */
+                vec_st((vector unsigned int) vd, 0, dstp);
+
+                srcp += 4;
+                dstp += 4;
+                width -= 4;
+                vs = voverflow;
+            }
+            ONE_PIXEL_BLEND((extrawidth), extrawidth);
+        }
+#undef ONE_PIXEL_BLEND
+
+        srcp += srcskip;
+        dstp += dstskip;
+    }
+
+}
+
+
+/* fast RGB888->(A)RGB888 blending */
+static void
+BlitRGBtoRGBSurfaceAlphaAltivec(SDL_BlitInfo * info)
+{
+    unsigned alpha = info->a;
+    int height = info->dst_h;
+    Uint32 *srcp = (Uint32 *) info->src;
+    int srcskip = info->src_skip >> 2;
+    Uint32 *dstp = (Uint32 *) info->dst;
+    int dstskip = info->dst_skip >> 2;
+    vector unsigned char mergePermute;
+    vector unsigned char valpha;
+    vector unsigned char valphamask;
+    vector unsigned short v1;
+    vector unsigned short v8;
+
+    mergePermute = VEC_MERGE_PERMUTE();
+    v1 = vec_splat_u16(1);
+    v8 = vec_splat_u16(8);
+
+    /* set the alpha to 255 on the destination surf */
+    valphamask = VEC_ALPHA_MASK();
+
+    /* set a vector full of alpha and 255-alpha */
+    ((unsigned char *) &valpha)[0] = alpha;
+    valpha = vec_splat(valpha, 0);
+
+    while (height--) {
+        int width = info->dst_w;
+#define ONE_PIXEL_BLEND(condition, widthvar) while ((condition)) { \
+            Uint32 s = *srcp; \
+            Uint32 d = *dstp; \
+            Uint32 s1 = s & 0xff00ff; \
+            Uint32 d1 = d & 0xff00ff; \
+            d1 = (d1 + ((s1 - d1) * alpha >> 8)) \
+                 & 0xff00ff; \
+            s &= 0xff00; \
+            d &= 0xff00; \
+            d = (d + ((s - d) * alpha >> 8)) & 0xff00; \
+            *dstp = d1 | d | 0xff000000; \
+            ++srcp; \
+            ++dstp; \
+            widthvar--; \
+        }
+        ONE_PIXEL_BLEND((UNALIGNED_PTR(dstp)) && (width), width);
+        if (width > 0) {
+            int extrawidth = (width % 4);
+            vector unsigned char valigner = VEC_ALIGNER(srcp);
+            vector unsigned char vs = (vector unsigned char) vec_ld(0, srcp);
+            width -= extrawidth;
+            while (width) {
+                vector unsigned char voverflow;
+                vector unsigned char vd;
+
+                /* s = *srcp */
+                voverflow = (vector unsigned char) vec_ld(15, srcp);
+                vs = vec_perm(vs, voverflow, valigner);
+
+                /* d = *dstp */
+                vd = (vector unsigned char) vec_ld(0, dstp);
+
+                VEC_MULTIPLY_ALPHA(vs, vd, valpha, mergePermute, v1, v8);
+
+                /* set the alpha channel to full on */
+                vd = vec_or(vd, valphamask);
+
+                /* *dstp = res */
+                vec_st((vector unsigned int) vd, 0, dstp);
+
+                srcp += 4;
+                dstp += 4;
+                width -= 4;
+                vs = voverflow;
+            }
+            ONE_PIXEL_BLEND((extrawidth), extrawidth);
+        }
+#undef ONE_PIXEL_BLEND
+
+        srcp += srcskip;
+        dstp += dstskip;
+    }
+}
+
+#if __MWERKS__
+#pragma altivec_model off
+#endif
+#endif /* SDL_ALTIVEC_BLITTERS */
+
 /* fast RGB888->(A)RGB888 blending with surface alpha=128 special case */
 static void
 BlitRGBtoRGBSurfaceAlpha128(SDL_BlitInfo * info)
@@ -1156,19 +1984,24 @@
     SDL_PixelFormat *dstfmt = info->dst_fmt;
     int srcbpp = srcfmt->BytesPerPixel;
     int dstbpp = dstfmt->BytesPerPixel;
-    Uint32 Pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB, dA;
-    const unsigned sA = info->a;
+    unsigned sA = info->a;
+    unsigned dA = dstfmt->Amask ? SDL_ALPHA_OPAQUE : 0;
 
     if (sA) {
         while (height--) {
 	    /* *INDENT-OFF* */
 	    DUFFS_LOOP4(
 	    {
+		Uint32 Pixel;
+		unsigned sR;
+		unsigned sG;
+		unsigned sB;
+		unsigned dR;
+		unsigned dG;
+		unsigned dB;
 		DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);
-		DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);
-		ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);
+		DISEMBLE_RGB(dst, dstbpp, dstfmt, Pixel, dR, dG, dB);
+		ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB);
 		ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
 		src += srcbpp;
 		dst += dstbpp;
@@ -1196,20 +2029,25 @@
     Uint32 ckey = info->colorkey;
     int srcbpp = srcfmt->BytesPerPixel;
     int dstbpp = dstfmt->BytesPerPixel;
-    Uint32 Pixel;
-    unsigned sR, sG, sB;
-    unsigned dR, dG, dB, dA;
-    const unsigned sA = info->a;
+    unsigned sA = info->a;
+    unsigned dA = dstfmt->Amask ? SDL_ALPHA_OPAQUE : 0;
 
     while (height--) {
 	    /* *INDENT-OFF* */
 	    DUFFS_LOOP4(
 	    {
+		Uint32 Pixel;
+		unsigned sR;
+		unsigned sG;
+		unsigned sB;
+		unsigned dR;
+		unsigned dG;
+		unsigned dB;
 		RETRIEVE_RGB_PIXEL(src, srcbpp, Pixel);
 		if(sA && Pixel != ckey) {
 		    RGB_FROM_PIXEL(Pixel, srcfmt, sR, sG, sB);
-		    DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);
-		    ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);
+		    DISEMBLE_RGB(dst, dstbpp, dstfmt, Pixel, dR, dG, dB);
+		    ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB);
 		    ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
 		}
 		src += srcbpp;
@@ -1234,11 +2072,9 @@
     int dstskip = info->dst_skip;
     SDL_PixelFormat *srcfmt = info->src_fmt;
     SDL_PixelFormat *dstfmt = info->dst_fmt;
+
     int srcbpp;
     int dstbpp;
-    Uint32 Pixel;
-    unsigned sR, sG, sB, sA;
-    unsigned dR, dG, dB, dA;
 
     /* Set up some basic variables */
     srcbpp = srcfmt->BytesPerPixel;
@@ -1248,11 +2084,20 @@
 	    /* *INDENT-OFF* */
 	    DUFFS_LOOP4(
 	    {
+		Uint32 Pixel;
+		unsigned sR;
+		unsigned sG;
+		unsigned sB;
+		unsigned dR;
+		unsigned dG;
+		unsigned dB;
+		unsigned sA;
+		unsigned dA;
 		DISEMBLE_RGBA(src, srcbpp, srcfmt, Pixel, sR, sG, sB, sA);
 		if(sA) {
-		    DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);
-		    ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA);
-		    ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
+		  DISEMBLE_RGBA(dst, dstbpp, dstfmt, Pixel, dR, dG, dB, dA);
+		  ALPHA_BLEND(sR, sG, sB, sA, dR, dG, dB);
+		  ASSEMBLE_RGBA(dst, dstbpp, dstfmt, dR, dG, dB, dA);
 		}
 		src += srcbpp;
 		dst += dstbpp;
@@ -1279,6 +2124,13 @@
             return BlitNto1PixelAlpha;
 
         case 2:
+#if SDL_ALTIVEC_BLITTERS
+            if (sf->BytesPerPixel == 4
+                && df->Gmask == 0x7e0 && df->Bmask == 0x1f
+                && SDL_HasAltiVec())
+                return Blit32to565PixelAlphaAltivec;
+            else
+#endif
                 if (sf->BytesPerPixel == 4 && sf->Amask == 0xff000000
                     && sf->Gmask == 0xff00
                     && ((sf->Rmask == 0xff && df->Rmask == 0x1f)
@@ -1310,10 +2162,19 @@
                 }
 #endif /* __MMX__ || __3dNOW__ */
                 if (sf->Amask == 0xff000000) {
+#if SDL_ALTIVEC_BLITTERS
+                    if (SDL_HasAltiVec())
+                        return BlitRGBtoRGBPixelAlphaAltivec;
+#endif
                     return BlitRGBtoRGBPixelAlpha;
                 }
             }
-            return BlitNtoNPixelAlpha;
+#if SDL_ALTIVEC_BLITTERS
+            if (sf->Amask && sf->BytesPerPixel == 4 && SDL_HasAltiVec())
+                return Blit32to32PixelAlphaAltivec;
+            else
+#endif
+                return BlitNtoNPixelAlpha;
 
         case 3:
         default:
@@ -1359,10 +2220,19 @@
                         return BlitRGBtoRGBSurfaceAlphaMMX;
 #endif
                     if ((sf->Rmask | sf->Gmask | sf->Bmask) == 0xffffff) {
+#if SDL_ALTIVEC_BLITTERS
+                        if (SDL_HasAltiVec())
+                            return BlitRGBtoRGBSurfaceAlphaAltivec;
+#endif
                         return BlitRGBtoRGBSurfaceAlpha;
                     }
                 }
-                return BlitNtoNSurfaceAlpha;
+#if SDL_ALTIVEC_BLITTERS
+                if ((sf->BytesPerPixel == 4) && SDL_HasAltiVec())
+                    return Blit32to32SurfaceAlphaAltivec;
+                else
+#endif
+                    return BlitNtoNSurfaceAlpha;
 
             case 3:
             default:
@@ -1373,11 +2243,16 @@
 
     case SDL_COPY_COLORKEY | SDL_COPY_MODULATE_ALPHA | SDL_COPY_BLEND:
         if (sf->Amask == 0) {
-            if (df->BytesPerPixel == 1) {
+            if (df->BytesPerPixel == 1)
                 return BlitNto1SurfaceAlphaKey;
-            } else {
+            else
+#if SDL_ALTIVEC_BLITTERS
+            if (sf->BytesPerPixel == 4 && df->BytesPerPixel == 4 &&
+                    SDL_HasAltiVec())
+                return Blit32to32SurfaceAlphaKeyAltivec;
+            else
+#endif
                 return BlitNtoNSurfaceAlphaKey;
-            }
         }
         break;
     }
diff -ru SDL.orig/src/video/SDL_blit_auto.c SDL/src/video/SDL_blit_auto.c
--- SDL.orig/src/video/SDL_blit_auto.c	2017-09-10 20:09:21.000000000 +0200
+++ SDL/src/video/SDL_blit_auto.c	2017-09-16 15:26:40.000000000 +0200
@@ -895,7 +895,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -969,7 +968,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -1125,7 +1123,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -1211,7 +1208,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -2102,7 +2098,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -2176,7 +2171,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -2332,7 +2326,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -2418,7 +2411,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -3309,7 +3301,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -3383,7 +3374,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -3539,7 +3529,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -3625,7 +3614,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -4521,7 +4509,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -4595,7 +4582,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -4751,7 +4737,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -4837,7 +4822,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -5733,7 +5717,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -5807,7 +5790,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -5963,7 +5945,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -6049,7 +6030,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -6945,7 +6925,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -7019,7 +6998,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -7175,7 +7153,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
@@ -7261,7 +7238,6 @@
                 dstR = srcR + ((255 - srcA) * dstR) / 255;
                 dstG = srcG + ((255 - srcA) * dstG) / 255;
                 dstB = srcB + ((255 - srcA) * dstB) / 255;
-                dstA = srcA + ((255 - srcA) * dstA) / 255;
                 break;
             case SDL_COPY_ADD:
                 dstR = srcR + dstR; if (dstR > 255) dstR = 255;
diff -ru SDL.orig/src/video/SDL_blit.h SDL/src/video/SDL_blit.h
--- SDL.orig/src/video/SDL_blit.h	2017-09-10 20:09:21.000000000 +0200
+++ SDL/src/video/SDL_blit.h	2017-09-16 15:26:40.000000000 +0200
@@ -440,22 +440,12 @@
     }                                                                   \
 }
 
-/* Blend the RGB values of two pixels with an alpha value */
-#define ALPHA_BLEND_RGB(sR, sG, sB, A, dR, dG, dB)                      \
+/* Blend the RGB values of two Pixels based on a source alpha value */
+#define ALPHA_BLEND(sR, sG, sB, A, dR, dG, dB)                          \
 do {                                                                    \
-    dR = ((((unsigned)(sR-dR)*(unsigned)A)/255)+dR);                    \
-    dG = ((((unsigned)(sG-dG)*(unsigned)A)/255)+dG);                    \
-    dB = ((((unsigned)(sB-dB)*(unsigned)A)/255)+dB);                    \
-} while(0)
-
-
-/* Blend the RGBA values of two pixels */
-#define ALPHA_BLEND_RGBA(sR, sG, sB, sA, dR, dG, dB, dA)                \
-do {                                                                    \
-    dR = ((((unsigned)(sR-dR)*(unsigned)sA)/255)+dR);                   \
-    dG = ((((unsigned)(sG-dG)*(unsigned)sA)/255)+dG);                   \
-    dB = ((((unsigned)(sB-dB)*(unsigned)sA)/255)+dB);                   \
-    dA = ((unsigned)sA+(unsigned)dA-((unsigned)sA*dA)/255);             \
+    dR = ((((int)(sR-dR)*(int)A)/255)+dR);                              \
+    dG = ((((int)(sG-dG)*(int)A)/255)+dG);                              \
+    dB = ((((int)(sB-dB)*(int)A)/255)+dB);                              \
 } while(0)
 
 
